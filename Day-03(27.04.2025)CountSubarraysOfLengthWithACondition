ğŸ“‹ Problem Statement:
Given an array nums of integers,
count the number of indices i such that the following condition holds:

2
Ã—
(
ğ‘›
ğ‘¢
ğ‘š
ğ‘ 
[
ğ‘–
]
+
ğ‘›
ğ‘¢
ğ‘š
ğ‘ 
[
ğ‘–
+
2
]
)
=
ğ‘›
ğ‘¢
ğ‘š
ğ‘ 
[
ğ‘–
+
1
]
2Ã—(nums[i]+nums[i+2])=nums[i+1]
Here, you need to consider triplets of elements at indices i, i+1, and i+2.

Make sure you don't go out of bounds of the array.

Finally, return the count of such triplets.

ğŸ§  Approach (Step-by-Step):
Initialize Variables:

Let n be the size of the array (n = nums.size()).

Initialize a counter count = 0 to keep track of how many valid triplets satisfy the condition.

Loop through the Array:

Start a for loop with i = 0 and run while i + 2 < n. (because we need three elements: nums[i], nums[i+1], and nums[i+2].)

Check the Condition:

For each i, check if:

2
Ã—
(
ğ‘›
ğ‘¢
ğ‘š
ğ‘ 
[
ğ‘–
]
+
ğ‘›
ğ‘¢
ğ‘š
ğ‘ 
[
ğ‘–
+
2
]
)
=
=
ğ‘›
ğ‘¢
ğ‘š
ğ‘ 
[
ğ‘–
+
1
]
2Ã—(nums[i]+nums[i+2])==nums[i+1]
If the condition is true, increment the count by 1.

Return the Result:
After the loop finishes, return the value of count.

âœ¨ Full Code:
int countSubarrays(vector<int>& nums) {
    int n = nums.size();
    int count = 0;
    for (int i = 0; i + 2 < n; i++) {
        if (2 * (nums[i] + nums[i+2]) == nums[i+1]) {
            count++;
        }
    }
    return count;
}
ğŸ“š Example:
Suppose nums = [1, 4, 1, 5, 2].

Now, let's check:

For i = 0 â†’ triplet (1,4,1):

2
Ã—
(
1
+
1
)
=
4
2Ã—(1+1)=4

2
Ã—
2
=
4
2Ã—2=4

4
=
4
4=4 âœ… â†’ count becomes 1.

For i = 1 â†’ triplet (4,1,5):

2
Ã—
(
4
+
5
)
=
1
2Ã—(4+5)=1

2
Ã—
9
=
18
2Ã—9=18

18
â‰ 
1
18
î€ 
=1 âŒ

For i = 2 â†’ triplet (1,5,2):

2
Ã—
(
1
+
2
)
=
5
2Ã—(1+2)=5

2
Ã—
3
=
6
2Ã—3=6

6
â‰ 
5
6
î€ 
=5 âŒ

So, final count = 1.

ğŸ›  Key Points:
Always ensure you don't access i+2 when it goes out of the array boundary.

Carefully frame the condition based on the problem.

Initialize variables properly to avoid runtime errors.

